/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.ProtectionController = function () {
    "use strict";

    var pendingNeedKeyData = [],
        audioInfo,
        videoInfo,

        onKeyMessage = function(e) {
            if (e.error) {
                this.debug.log(e.error);
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            e.error);
            } else {
                var keyMessageEvent = e.data;
                this.debug.log("[DRM] onKeyMessage: message = " + keyMessageEvent.message);
                this.protectionModel.keySystem.doLicenseRequest(keyMessageEvent.message,
                    keyMessageEvent.defaultURL, keyMessageEvent.sessionToken);
            }
        },

        onKeyStatusChanged = function(e) {
            if (e.error) {
                this.debug.log(e.error);
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            e.error);
            }else {
                this.debug.log("[DRM] onKeyStatusChanged: status = " + e.data.status+" pour keyID = "+e.data.keyId);
            }
        },

        onLicenseRequestComplete = function(e) {
            if (!e.error) {
                this.debug.log("[DRM] License request successful.  Session ID = " + e.data.requestData.getSessionID());
                this.updateKeySession(e.data.requestData, e.data.message);
            } else {
                this.debug.log("[DRM] License request failed! -- " + e.error);
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            e.error);
            }
        },

        onKeySystemSelected = function() {
            this.protectionModel.keySystem.subscribe(MediaPlayer.dependencies.protection.KeySystem.eventList.ENAME_LICENSE_REQUEST_COMPLETE, this);

            this.debug.log("[DRM] Key system selected: " + this.protectionModel.keySystem.ks);

            // ProtectionModel now has an associated KeySystem.  Process any pending initData
            // generated by needkey/encrypted events
            if (!this.keySystem) {
                this.keySystem = this.protectionModel.keySystem;
            }
            for (var i = 0; i < pendingNeedKeyData.length; i++) {
                this.createKeySession(pendingNeedKeyData[i]);
            }
            pendingNeedKeyData = [];
        },

        onNeedKey = function (event) {

            // Ignore non-cenc initData
            if (event.data.initDataType !== "cenc") {
                this.debug.log("[DRM] Only 'cenc' initData is supported!  Ignoring initData of type: " + event.data.initDataType);
                return;
            }

            this.debug.log("[DRM] NeedKey");

            // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).
            // Convert to ArrayBuffer
            var abInitData = event.data.initData;
            if (ArrayBuffer.isView(abInitData)) {
                abInitData = abInitData.buffer;
            }

            //this.debug.log("[DRM] onNeedKey: " + this.protectionModel.keySystem.ks);

            if (this.keySystem) {
                // We have a key system
                this.createKeySession(abInitData, this.keySystem.cdmData);
            }
            else if (this.keySystem === undefined) {
                // First time through, so we need to select a key system
                this.keySystem = null;
                pendingNeedKeyData.push(abInitData);
                try {
                    this.protectionExt.autoSelectKeySystem(this.protectionExt.getSupportedKeySystems(abInitData),
                            this, videoInfo, audioInfo);
                } catch (error) {
                    this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_UNSUPPORTED, "[DRM] Unable to select a key system from needkey initData. -- " + error.message, null));
                }
            } else {
                // We are in the process of selecting a key system, so just save the data
                pendingNeedKeyData.push(abInitData);
            }
        },

        onKeySystemAccessComplete = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] KeySystem Access Granted");
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, "[DRM] KeySystem Access Denied! -- " + event.error, null));
            }
        },

        onServerCertificateUpdated = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] License server certificate successfully updated.");
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_UPDATE_CERTIFICATE_IMPOSSIBLE, "[DRM] Failed to update license server certificate. -- " + event.error, null));
            }
        },

        onKeySessionCreated = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session created.  SessionID = " + event.data.getSessionID());
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION, "[DRM] Failed to create key session. -- " + event.error, null));
            }
        },

        onKeyAdded = function (/*event*/) {
            this.debug.log("[DRM] Key added.");
        },

        onKeyError = function (event) {
            this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR, event.data.error);
        },

        onKeySessionClosed = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session closed.  SessionID = " + event.data);
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CLOSE_SESSION, "[DRM] Failed to close key session. -- " + event.error, null));
            }
        },

        onKeySessionRemoved = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session removed.  SessionID = " + event.data);
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_REMOVE_SESSION, "[DRM] Failed to remove key session. -- " + event.error, null));
            }
        };

    return {
        system : undefined,
        debug : undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        protectionExt: undefined,
        keySystem: undefined,
        manifestExt: undefined,
        sessionType: "temporary",

        setup : function () {
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE] = onKeyMessage.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED] = onKeySystemSelected.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = onKeySystemAccessComplete.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY] = onNeedKey.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED] = onServerCertificateUpdated.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED] = onKeyAdded.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR] = onKeyError.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED] = onKeySessionCreated.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED] = onKeySessionClosed.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED] = onKeySessionRemoved.bind(this);
            this[MediaPlayer.dependencies.protection.KeySystem.eventList.ENAME_LICENSE_REQUEST_COMPLETE] = onLicenseRequestComplete.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED] = onKeyStatusChanged.bind(this);

            this.protectionModel = this.system.getObject("protectionModel");
            this.protectionModel.init();
        },

        init: function (manifest) {
            var self = this;

            // Subscribe to events
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);
            /*
             TODO:  This event is causing failures in Stream.js.  The message causes a PROTECTION_ERROR notification which
             triggers the call of Stream.reset().  Stream.reset() unsubscribes from PROTECTION_ERROR messages which makes
             Notifier very unhappy.  Need to fix that bug first.
              */
            //this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, this);

            // Look for ContentProtection elements.  InitData can be provided by either the
            // dash264drm:Pssh ContentProtection format or a DRM-specific format.
            /*var adapter = this.system.getObject("adapter"),
                streamInfo = adapter.getStreamsInfo(manifest)[0]; // TODO: Single period only for now.
            audioInfo = adapter.getMediaInfoForType(manifest, streamInfo, "audio");
            videoInfo = adapter.getMediaInfoForType(manifest, streamInfo, "video");
            var mediaInfo = (videoInfo) ? videoInfo : audioInfo; // We could have audio or video only*/

            // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio
            // and video will be the same.  Just use one valid MediaInfo object
            //var supportedKS = this.protectionExt.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection);

            this.manifestExt.getVideoData(manifest, 0).then(
                function (videoData) {
                    self.manifestExt.getPrimaryAudioData(manifest, 0).then(
                        function (audioData) {
                            self.manifestExt.getContentProtectionData(videoData).then(
                                function (contentProtectionData) {
                                    var supportedKS = self.protectionExt.getSupportedKeySystemsFromContentProtection(contentProtectionData);

                                    if (supportedKS && supportedKS.length > 0) {

                                        // Handle KEY_SYSTEM_SELECTED events here instead.
                                        var ksSelected = {};
                                        //var self = this;
                                        ksSelected[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED] = function(event) {
                                            self.debug.log("[DRM] Key system selected");
                                            if (!event.error) {
                                                self.keySystem = self.protectionModel.keySystem;
                                                self.keySystem.subscribe(MediaPlayer.dependencies.protection.KeySystem.eventList.ENAME_LICENSE_REQUEST_COMPLETE, self);
                                                for (var ksIdx = 0; ksIdx < supportedKS.length; ksIdx++) {
                                                    if (self.keySystem === supportedKS[ksIdx].ks) {
                                                        self.debug.log("[DRM] Create key session for key system " + self.keySystem.systemString);
                                                        self.createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);
                                                        break;
                                                    }
                                                }
                                            } else {
                                                self.debug.log("[DRM] Could not select key system from ContentProtection elements!  Falling back to needkey mechanism...");
                                                self.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, self);
                                                self.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, self);
                                            }
                                            self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
                                        };
                                        self.keySystem = null;
                                        self.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
                                        self.protectionExt.autoSelectKeySystem(supportedKS, self, self.manifestExt.getCodec_(videoData), self.manifestExt.getCodec_(audioData));
                                    } else { // needkey event will trigger key system selection
                                        self.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, self);
                                        self.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, self);
                                    }
                                }
                            );
                        }
                    );
                }
            );

        },

        teardown: function() {
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, this);
            if (this.protectionModel.keySystem) {
                this.protectionModel.keySystem.unsubscribe(MediaPlayer.dependencies.protection.KeySystem.eventList.ENAME_LICENSE_REQUEST_COMPLETE, this);
            }

            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);
            this.keySystem = undefined;

            this.protectionModel.teardown();
            this.protectionModel = undefined;
        },

        requestKeySystemAccess: function(ksConfiguration) {
            this.protectionModel.requestKeySystemAccess(ksConfiguration);
        },

        selectKeySystem: function(keySystemAccess) {
            if (this.protectionModel.keySystem) {
                throw new Error("[DRM] KeySystem already selected!");
            }
            this.protectionModel.selectKeySystem(keySystemAccess);
        },

        createKeySession: function(initData, cdmData) {
            this.debug.log("[DRM] Create key session, initData = " + initData);
            var initDataForKS = MediaPlayer.dependencies.protection.CommonEncryption.getPSSHForKeySystem(this.keySystem, initData);
            if (initDataForKS) {
                try {
                    this.protectionModel.createKeySession(initDataForKS, this.sessionType, cdmData);
                } catch (error) {
                    this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION, "Error creating key session! " + error.message,null));
                }
            } else {
                this.debug.log("[DRM] Selected key system is " + this.keySystem.systemString + ".  needkey/encrypted event contains no initData corresponding to that key system!");
            }
        },

        updateKeySession: function(sessionToken, message) {
            this.protectionModel.updateKeySession(sessionToken, message);
        },

        loadKeySession: function(sessionID) {
            this.protectionModel.loadKeySession(sessionID);
        },

        removeKeySession: function(sessionToken) {
            this.protectionModel.removeKeySession(sessionToken);
        },

        closeKeySession: function(sessionToken) {
            this.protectionModel.closeKeySession(sessionToken);
        },

        setServerCertificate: function(serverCertificate) {
            this.protectionModel.setServerCertificate(serverCertificate);
        },

        setMediaElement: function(element) {
            this.protectionModel.setMediaElement(element);
        },

        setSessionType: function(sessionType) {
            this.sessionType = sessionType;
        },

        /**
         * Attach KeySystem-specific data to use for License Acquisition with EME
         *
         * @param data and object containing property names corresponding to key
         * system name strings and associated values being instances of
         * MediaPlayer.vo.protection.ProtectionData
         */
        setProtectionData: function(data) {
            this.protectionExt.init(data);
        }
    };

};

MediaPlayer.dependencies.ProtectionController.eventList = {
    ENAME_PROTECTION_ERROR: "protectionError"
};

MediaPlayer.dependencies.ProtectionController.prototype = {
    constructor: MediaPlayer.dependencies.ProtectionController
};


